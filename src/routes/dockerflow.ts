/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
// @flow

// In this router we implement the services required by the dockerflow mozilla
// best practices, as described in https://github.com/mozilla-services/Dockerflow.

import Router from '@koa/router';
import fs from 'fs';

import { getLogger } from '../log';
import { config } from '../config';
import { create as gcsStorageCreate } from '../logic/gcs';
import * as BitLy from '../logic/shorten-url';

export function dockerFlowRoutes() {
  const log = getLogger('routes.dockerflow');

  const router = new Router();

  // "Respond to /__version__ with the contents of /app/version.json."
  // This file is generated by the script bin/generate-verison-file.js at build
  // time in CircleCI and lives in dist/version.json.
  // We serve it directly if present, otherwise returns a 404.
  router.get('/__version__', async (ctx) => {
    // We try to get the version file in the current working directory.
    const versionFilePath = 'version.json';
    try {
      const stat = await fs.promises.stat(versionFilePath);
      ctx.lastModified = stat.mtime;

      // We could try to conditionally answer depending on cache-related headers
      // in the request but this is a lot of work for this small file.
      const content = await fs.promises.readFile(versionFilePath);
      ctx.body = content;
      ctx.type = 'json';
    } catch (e: any) {
      if (e.code === 'ENOENT') {
        // ENOENT means "No such file or directory"
        throw new Error(
          `The version file (${versionFilePath}) could not be found.`
        );
      }

      // Rethrow the error otherwise.
      throw e;
    }
  });

  // "Respond to /__heartbeat__ with a HTTP 200 or 5xx on error. This should
  // check backing services like a database for connectivity and may respond
  // with the status of backing services and application components as a JSON
  // payload."
  router.get('/__heartbeat__', async (ctx) => {
    // In this heartbeat endpoint, we need to ping 3rd party servers.
    // 1. Google Cloud Storage
    const storage = gcsStorageCreate(config);
    const googlePromise = storage.ping().then(
      () => {
        log.debug('heartbeat_gcs', 'GCS ping was successful.');
      },
      (e) => {
        log.error(
          'heartbeat_gcs_error',
          `GCS ping was unsuccessful: (${e.name}) ${e.message}`
        );
        throw e;
      }
    );

    // 2. BitLy
    const bitlyPromise = BitLy.retrieveCurrentUser().then(
      () => {
        log.debug('heartbeat_bitly', 'BitLy ping was successful.');
      },
      (e) => {
        log.error(
          'heartbeat_bitly_error',
          `BitLy ping was unsuccessful: (${e.name}) ${e.message}`
        );
        throw e;
      }
    );

    // Wait for all 3rd party services.
    await Promise.all([googlePromise, bitlyPromise]);

    ctx.body = 'OK';
  });

  //
  // "Respond to /__lbheartbeat__ with an HTTP 200. This is for load balancer
  // checks and should not check backing services."
  router.get('/__lbheartbeat__', (ctx) => {
    ctx.body = 'OK';
  });

  return router;
}
